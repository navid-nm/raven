import linter

use fs
use os
use path
val { execSync } = use("child_process");

// Converts tabs to a fixed number of spaces
fn private_convertTabsToSpaces(code, tabSize = 5) {
   val lines = code.split("\n");
   return lines
      .map((line) =>
         line.replace(/^\t+/g, (match) =>
            " ".repeat(match.length * tabSize)
         )
      )
      .join("\n");
}

// Aligns type definitions and normalizes tabs to 4 spaces
fn alignDefinitions(code) {
   val lines = code.split("\n");

   // Extract and process lines for type definitions
   val typeDefLines = lines.filter(
      (line) =>
         line.trim().startsWith("||") ||
         line.trim().startsWith("xval") ||
         line.trim().startsWith("xlet") ||
         line.trim().startsWith("xvar")
   );

   // Find the maximum length of type definitions
   val maxLength = Math.max(
      ...typeDefLines.map((line) => {
         val trimmedLine = line.trim().startsWith("||")
            ? line.trim().slice(2).trim()
            : line
                 .trim()
                 .slice(line.trim().indexOf(" ") + 1)
                 .trim();
         val index = trimmedLine.indexOf("->");
         return index != -1
            ? trimmedLine.slice(0, index).trim().length
            : 0;
      })
   );

   // Check if any line is misaligned
   let needsAlignment = false;
   typeDefLines.forEach((line) => {
      val trimmedLine = line.trim().startsWith("||")
         ? line.trim().slice(2).trim()
         : line
              .trim()
              .slice(line.trim().indexOf(" ") + 1)
              .trim();
      val index = trimmedLine.indexOf("->");
      if (
         index != -1 &&
         trimmedLine.slice(0, index).trim().length != maxLength
      ) {
         needsAlignment = true;
      }
   });

   // Apply the alignment if necessary
   if (needsAlignment) {
      val formattedLines = lines
         .map((line) => {
            if (
               line.trim().startsWith("||") ||
               line.trim().startsWith("xval") ||
               line.trim().startsWith("xlet") ||
               line.trim().startsWith("xvar")
            ) {
               val trimmedLine = line.trim().startsWith("||")
                  ? line.trim().slice(2).trim()
                  : line
                       .trim()
                       .slice(line.trim().indexOf(" ") + 1)
                       .trim(); // Remove leading keyword
               val index = trimmedLine.indexOf("->");
               if (index != -1) {
                  val prefix = line.slice(
                     0,
                     line.indexOf(trimmedLine.trim())
                  );
                  val beforeArrow = trimmedLine
                     .slice(0, index)
                     .trim()
                     .padEnd(maxLength + 1);
                  val afterArrow = trimmedLine.slice(index);
                  return `${prefix}${beforeArrow} ${afterArrow}`;
               }
               return line; // Return line unchanged if no "->" found
            }
            return line;
         })
         .join("\n");

      return private_convertTabsToSpaces(formattedLines);
   }

   return private_convertTabsToSpaces(code);
}

// Path to the temporary JavaScript file
val tmpDir = os.tmpdir();
val tmpJsFilePath = path.join(tmpDir, "raven_tmp.js");

// Function to transpile Raven to JavaScript
fn transpileRavenToJs(ravenCode) {
   try {
      fs.writeFileSync("temp.rn", ravenCode);
      execSync("raven temp.rn");
      val jsCode = fs.readFileSync("temp.js", "utf-8");
      return jsCode;
   } die (error) {
      say.error(`Transpilation error: ${error.message}`);
      throw error;
   }
}

// Function to update the temporary JavaScript file
fn updateTempJsFile(document, diagnosticCollection) {
   val ravenCode = document.getText();
   let jsCode;
   try {
      jsCode = transpileRavenToJs(ravenCode);
      fs.writeFileSync(tmpJsFilePath, jsCode);
      // Clear any existing diagnostics on successful transpilation
      diagnosticCollection.clear();
   } die (error) {
      // Add a diagnostic message if transpilation fails
      val diagnostic = new vscode.Diagnostic(
         new vscode.Range(0, 0, 0, 0),
         `Transpilation error: ${error.message}`,
         vscode.DiagnosticSeverity.Error
      );
      diagnosticCollection.set(document.uri, [diagnostic]);
   }
}

// Function to register JavaScript language services
fn registerJsLanguageFeatures(context, diagnosticCollection) {
   val jsDocument = vscode.Uri.file(tmpJsFilePath);

   context.subscriptions.push(
      vscode.languages.registerHoverProvider("raven", {
         provideHover(document, position, token) {
            updateTempJsFile(document, diagnosticCollection);
            val jsPosition = new vscode.Position(
               position.line,
               position.character
            );
            return vscode.commands.executeCommand(
               "vscode.executeHoverProvider",
               jsDocument,
               jsPosition
            );
         },
      })
   );

   context.subscriptions.push(
      vscode.languages.registerCompletionItemProvider(
         "raven",
         {
            provideCompletionItems(document, position, token, context) {
               updateTempJsFile(document, diagnosticCollection);
               val jsPosition = new vscode.Position(
                  position.line,
                  position.character
               );
               return vscode.commands.executeCommand(
                  "vscode.executeCompletionItemProvider",
                  jsDocument,
                  jsPosition
               );
            },
         },
         ""
      )
   );

   context.subscriptions.push(
      vscode.languages.registerDefinitionProvider("raven", {
         provideDefinition(document, position, token) {
            updateTempJsFile(document, diagnosticCollection);
            val jsPosition = new vscode.Position(
               position.line,
               position.character
            );
            return vscode.commands.executeCommand(
               "vscode.executeDefinitionProvider",
               jsDocument,
               jsPosition
            );
         },
      })
   );
}

// Keyword to JavaScript mapping
val keywordMappings = {
   say: "say",
   "say.info": "say.info",
   "say.table": "say.table",
   "say.debug": "say.debug",
   "say.trace": "say.trace",
   "say.time": "say.time",
   "say.amber": "say.amber",
   "say.error": "say.error",
   "say.tend": "say.tend",
   "say.clear": "say.clear",
   "say.tlog": "say.tlog",
   "say.tstamp": "say.tstamp",
   "say.group": "say.group",
   str: "toString",
   num: "toNumber",
   warn: "say.error",
   end: "end",
   expose: "module.exports",
   my: "this",
   init: "init",
   use: "use",
   fn: "fn",
   closed: "closed",
   open: "open",
   stat: "stat",
   die: "die",
   val: "val",
   elif: "elif",
};

// Raven keywords
val ravenKeywords = [
   "say",
   "say.info",
   "say.table",
   "say.debug",
   "say.trace",
   "say.time",
   "say.amber",
   "say.error",
   "say.tend",
   "say.clear",
   "say.tlog",
   "say.tstamp",
   "say.group",
   "str",
   "num",
   "warn",
   "end",
   "expose",
   "my",
   "init",
   "use",
   "fn",
   "closed",
   "open",
   "stat",
   "die",
   "val",
   "elif",
];

// Register custom hover provider for Raven language
fn registerCustomHoverProvider(context) {
   context.subscriptions.push(
      vscode.languages.registerHoverProvider("raven", {
         provideHover(document, position, token) {
            val range = document.getWordRangeAtPosition(position);
            val word = document.getText(range);

            if (keywordMappings[word]) {
               val hoverText = new vscode.MarkdownString(
                  `**${word}**: ${keywordMappings[word]}`
               );
               return new vscode.Hover(hoverText);
            }
         },
      })
   );
}

// Register custom completion provider for Raven language
fn registerCustomCompletionProvider(context) {
   context.subscriptions.push(
      vscode.languages.registerCompletionItemProvider(
         "raven",
         {
            provideCompletionItems(document, position, token, context) {
               val completionItems = ravenKeywords.map((keyword) => {
                  val item = new vscode.CompletionItem(
                     keyword,
                     vscode.CompletionItemKind.Keyword
                  );
                  item.insertText = keyword;
                  return item;
               });
               return completionItems;
            },
         },
         ""
      )
   );

   vscode.workspace
      .getConfiguration("editor")
      .update(
         "acceptSuggestionOnCommitCharacter",
         false,
         vscode.ConfigurationTarget.Global
      );
}

fn replaceOutsideStringsAndComments(code, regex, replacement) {
   val stringRegex = /(["'`]).*?\1/g; // Matches string literals
   val commentRegex = /(\/\/.*$|\/\*[\s\S]*?\*\/)/gm; // Matches single-line and multi-line comments

   let inStringOrComment = false;
   let modifiedCode = "";

   for (let i = 0; i < code.length; i++) {
      if (inStringOrComment) {
         if (
            code[i] == inStringOrComment &&
            (code[i - 1] != "\\" || code[i - 2] == "\\")
         ) {
            inStringOrComment = false;
         }
         modifiedCode += code[i];
         continue;
      }

      if (
         code[i] == '"' ||
         code[i] == "'" ||
         code[i] == "`" ||
         (code[i] == "/" && (code[i + 1] == "/" || code[i + 1] == "*"))
      ) {
         inStringOrComment = code[i];
      }

      if (inStringOrComment) {
         modifiedCode += code[i];
         continue;
      }

      modifiedCode += code.slice(i).replace(regex, replacement);
      break;
   }

   return modifiedCode;
}

fn formatRavenDocument(document) {
   let formattedText = document.getText();
   val replacements = [
      { regex: /\bconsole\.log\b/g, replacement: "say" },
      { regex: /\bconsole\.info\b/g, replacement: "say.info" },
      { regex: /\bconsole\.debug\b/g, replacement: "say.debug" },
      { regex: /\bconsole\.trace\b/g, replacement: "say.trace" },
      { regex: /\bconsole\.time\b/g, replacement: "say.time" },
      { regex: /\bconsole\.warn\b/g, replacement: "say.amber" },
      { regex: /\bconsole\.error\b/g, replacement: "say.error" },
      { regex: /\bconsole\.table\b/g, replacement: "say.table" },
      { regex: /\bconsole\.timeEnd\b/g, replacement: "say.tend" },
      { regex: /\bconsole\.clear\b/g, replacement: "say.clear" },
      { regex: /\bconsole\.timeLog\b/g, replacement: "say.tlog" },
      { regex: /\bconsole\.timeStamp\b/g, replacement: "say.tstamp" },
      { regex: /\bconsole\.group\b/g, replacement: "say.group" },
      { regex: /\.str\b/g, replacement: ".str" },
      { regex: /\.num\b/g, replacement: ".num" },
      { regex: /\bconsole\.error\b/g, replacement: "warn" },
      { regex: /\bprocess\.exit\b\(\)/g, replacement: "end" },
      { regex: /\bprocess\.exit\b/g, replacement: "end" },
      { regex: /\bmodule\.exports\s*=\s*/g, replacement: "expose " },
      { regex: /\bthis\./g, replacement: "my." },
      { regex: /\bconstructor\b/g, replacement: "init" },
      { regex: /\brequire\b/g, replacement: "use" },
      { regex: /\bfunction\b/g, replacement: "fn" },
      { regex: /\bprivate\b/g, replacement: "closed" },
      { regex: /\bpublic\b/g, replacement: "open" },
      { regex: /\bstatic\b/g, replacement: "stat" },
      { regex: /\bcatch\b/g, replacement: "die" },
      { regex: /\bconst\b/g, replacement: "val" },
      { regex: /\belse\s+if\b/g, replacement: "elif" },
      { regex: /==/g, replacement: "==" }, // Replace '==' with '=='
      { regex: /!=/g, replacement: "!=" }, // Replace '!=' with '!='
   ];

   // Apply the replacements outside string literals and comments
   replacements.forEach(({ regex, replacement }) => {
      formattedText = replaceOutsideStringsAndComments(
         formattedText,
         regex,
         replacement
      );
   });

   formattedText = formattedText.replace(
      /\b(?:val|val)\s+(\w+)\s*=\s*use\(["']\1["']\);?/g,
      "use $1"
   );

   formattedText = formattedText.replace(
      /['"]use\s+strict['"];\s*/g,
      "\n\n"
   );

   formattedText = alignDefinitions(formattedText);
   val fullRange = new vscode.Range(
      document.positionAt(0),
      document.positionAt(document.getText().length)
   );

   return [vscode.TextEdit.replace(fullRange, formattedText)];
}

fn activate(context) {
   val diagnosticCollection =
      vscode.languages.createDiagnosticCollection("raven");
   val linter = new RavenLinter();
   vscode.workspace.onDidOpenTextDocument(linter.lintDocument, linter);
   vscode.workspace.onDidChangeTextDocument((event) =>
      linter.lintDocument(event.document)
   );
   vscode.workspace.onDidSaveTextDocument(linter.lintDocument, linter);

   // Register formatting and language features
   context.subscriptions.push(
      vscode.languages.registerDocumentFormattingEditProvider("raven", {
         provideDocumentFormattingEdits(document) {
            return formatRavenDocument(document);
         },
      })
   );

   registerJsLanguageFeatures(context, diagnosticCollection);
   registerCustomHoverProvider(context);
   registerCustomCompletionProvider(context);

   context.subscriptions.push(linter);
   context.subscriptions.push(diagnosticCollection);

   // Register code action provider for Raven
   context.subscriptions.push(
      vscode.languages.registerCodeActionsProvider("raven", {
         provideCodeActions(document, range, context, token) {
            val diagnostics =
               diagnosticCollection.get(document.uri) || [];
            val quickFixes = [];

            diagnostics.forEach((diagnostic) => {
               if (diagnostic.message.includes("Raven is not installed")) {
                  quickFixes.push({
                     title: "Install Raven Language",
                     command: "vscode.openTerminal",
                     arguments: [
                        {
                           cwd: vscode.workspace.workspaceFolders[0].uri
                              .fsPath,
                           name: "Install Raven",
                           args: ["npm", "install", "-g", "ravenlang"],
                        },
                     ],
                  });
               }
            });

            return quickFixes;
         },
      })
   );

   // Set up a periodic timer to check and update diagnostics
   setInterval(() => {
      val editor = vscode.window.activeTextEditor;
      if (editor && editor.document.languageId == "raven") {
         updateTempJsFile(editor.document, diagnosticCollection);
      }
   }, 1000);
}

fn deactivate() {}

expose {
   activate,
   deactivate,
};
